#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift(File.expand_path('../lib', __dir__))
require 'thor'
require 'json'
require 'nacha' # Assuming this loads the Nacha gem

module Nacha
  class CLI < Thor
    TEMPLATES_DIR = File.join(Gem::Specification.find_by_name("nacha").gem_dir,
      "templates").freeze

    HTML_PREAMBLE_FILE = File.join(TEMPLATES_DIR, "html_preamble.html")
    HTML_POSTAMBLE_FILE = File.join(TEMPLATES_DIR, "html_postamble.html")

    desc "parse FILE", "Parse an ACH file"
    option :output_file, aliases: "-o"
    option :format, aliases: "-f", default: "html",
      desc: "Output format (html, json, or ach)", enum: %w[html json ach]
    def parse(file_path)
      unless File.exist?(file_path)
        puts "Error: File not found at #{file_path}"
        exit 1
      end

      ach_file = [Nacha.parse(File.open(file_path)).first] # Use Nacha.parse

      # TODO: Determine a user-friendly way to output the parsed data.
      # For now, let's print the records.
      if ach_file && ach_file.is_a?(Array) && !ach_file.empty?
        if options[:output_file]
          File.open(options[:output_file], "w") do |file|
            write_output(file_path, ach_file, file)
          end
        else
          write_output(file_path, ach_file, $stdout)
        end
      else
        puts "Could not parse the file or the file was empty."
      end
    rescue StandardError => e
      puts "An error occurred during parsing: #{e.message}"
      puts e.backtrace.join("\n")
      exit 1
    end

    private

    def write_output(file_path, ach_records, io)
      case options[:format]
      when 'html'
        output_html(file_path, ach_records, io)
      when 'json'
        output_json(ach_records, io)
      when 'ach'
        output_ach(ach_records, io)
      end
    end

    def output_json(ach_records, io)
      json_output = ach_records.map { |record| record_to_h(record) }
      io.puts JSON.pretty_generate(json_output)
    end

    def record_to_h(record)
      {
        record.class.name.split('::').last => {
          fields: record.fields.transform_values(&:to_s),
          children: record.children.map { |child| record_to_h(child) }
        }
      }
    end

    def output_ach(ach_records, io)
      ach_records.each do |record|
        io.puts record.original_input_line
        output_ach(record.children, io) if record.children.any?
      end
    end

    def output_html(file_path, ach_records, io)
      io.puts html_preamble
      io.puts "<h1>Successfully parsed #{file_path}</h1>\n"
      ach_records.each do |record|
        display_child(0, record, io)
      end
      io.puts html_postamble
    end

    def html_preamble
      @html_preamble ||= File.read(HTML_PREAMBLE_FILE)
    end

    def html_postamble
      @html_postamble ||= File.read(HTML_POSTAMBLE_FILE)
    end

    def display_child(level, record, io)
      # Attempt to call a summary or to_s method if it exists,
      # otherwise inspect the record.
      return unless record

      io.puts record.to_html
      return unless record.respond_to?(:children) && record.children.any?

      record.children.each do |child_record|
        display_child(level + 1, child_record, io)
      end
    end
  end
end

Nacha::CLI.start(ARGV)
